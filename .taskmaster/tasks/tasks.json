{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Install and Configure NextAuth.js v5",
        "description": "Set up NextAuth.js v5 in the Next.js 15 project, including installation, environment variables, and initial configuration.",
        "details": "Run `pnpm i next-auth@beta` to install NextAuth.js v5. Generate a secure secret key using `openssl rand -base64 32` and add it to `.env` as `AUTH_SECRET`. Create `auth.config.ts` at the project root with the `pages` option to specify custom sign-in routes. Ensure the configuration is compatible with Next.js 15 and TypeScript. Reference the official migration guide for v5-specific changes.",
        "testStrategy": "Verify that the NextAuth.js configuration loads without errors and that the `/api/auth/[...nextauth]` endpoint is available. Check that the secret is loaded from environment variables.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Credentials Provider for Email/Password Authentication",
        "description": "Configure NextAuth.js to use a credentials provider for email and password authentication.",
        "details": "In the NextAuth.js configuration, add a credentials provider that accepts email and password. Implement the `authorize` callback to validate credentials against the user database (stub or mock for now, as DB is to be added later). Ensure passwords are hashed and compared securely using a library like bcrypt. Return user object on success, or null on failure.",
        "testStrategy": "Test login attempts with valid and invalid credentials. Ensure correct error messages are returned and that no sensitive information is leaked.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Login Form UI Component",
        "description": "Develop a simple, secure login form using Next.js, TypeScript, and Tailwind CSS.",
        "details": "Build a login page at `/login` with email and password fields. Use a form that submits to the NextAuth.js sign-in endpoint. Style the form for clarity and accessibility using Tailwind CSS. Display error messages for failed logins and loading indicators during submission. Ensure the form is the first screen users see.",
        "testStrategy": "Manually test the form for correct field validation, error handling, and accessibility. Use automated tests to check form submission and UI rendering.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Develop Developer-Only Signup Form Component",
        "description": "Implement a signup form for developer use, hidden in production, to create new users.",
        "details": "Create a signup page and form component with email and password fields. The form should call a backend API route to create a new user, hashing the password before storage. Use environment variables to conditionally render the signup form only in development. Hide or disable the route in production builds.",
        "testStrategy": "Test signup in development mode, ensuring new users are created and passwords are hashed. Confirm the form is not accessible in production.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Session Management and Protected Routes",
        "description": "Set up session management using NextAuth.js and protect routes that require authentication.",
        "details": "Use NextAuth.js session hooks to check authentication status. Implement middleware or server-side checks to redirect unauthenticated users from protected pages (e.g., main chat interface) to the login page. Ensure session tokens are securely managed and refreshed as needed.",
        "testStrategy": "Attempt to access protected routes while logged out and confirm redirection to login. Verify authenticated users can access protected content.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Environment-Based Conditional UI Rendering",
        "description": "Control the visibility of the signup form and other UI elements based on environment (development or production).",
        "details": "Use environment variables (e.g., `NODE_ENV`) to conditionally render the signup form and any developer-only features. Ensure that production builds do not expose developer-only UI. Add checks in both frontend and backend to enforce this.",
        "testStrategy": "Build and run the app in both development and production modes. Confirm that developer-only features are hidden in production.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Integrate Authentication Flow with Main Chat Interface",
        "description": "Connect the authentication flow to the main chat interface, ensuring only authenticated users can access it.",
        "details": "After successful login, redirect users to the main chat interface. Use session state to control access. Ensure logout returns users to the login page. Integrate session checks into the chat interface to prevent unauthorized access.",
        "testStrategy": "Test end-to-end user flow: login, access chat, logout, and attempt to access chat while logged out. Confirm correct redirections and access control.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Comprehensive Integration Testing and Error Handling",
        "description": "Test the complete authentication flow, error handling, and user feedback across environments.",
        "details": "Write integration tests for login, signup (dev only), session management, and protected routes. Test error scenarios (invalid credentials, expired sessions, etc.). Ensure user-friendly error messages and feedback. Test both development and production builds for correct behavior.",
        "testStrategy": "Automate tests using a framework like Jest and Playwright. Manually test edge cases and UI feedback. Review logs for security and error reporting.",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-24T14:12:16.662Z",
      "updated": "2025-10-24T14:12:16.662Z",
      "description": "Tasks for master context"
    }
  },
  "database-integration": {
    "tasks": [
      {
        "id": 1,
        "title": "Set Up Vercel Postgres Database",
        "description": "Provision and configure a Vercel Postgres database instance for the application.",
        "details": "Create a new Vercel Postgres database via the Vercel dashboard. Retrieve connection credentials and store them securely in environment variables (e.g., DATABASE_URL). Ensure the database is accessible from both local and Vercel environments. Document the connection string format and access policies.",
        "testStrategy": "Connect to the database using a simple script or Prisma CLI to verify connectivity and permissions. Confirm environment variables are correctly loaded in both local and deployed environments.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Install and Configure Prisma ORM",
        "description": "Integrate Prisma ORM with the Next.js project and connect it to Vercel Postgres.",
        "details": "Install Prisma and @prisma/client via npm. Initialize Prisma in the project root. Configure the Prisma schema to use the DATABASE_URL from environment variables. Generate the initial Prisma client.",
        "testStrategy": "Run `prisma generate` and `prisma db pull` to ensure Prisma can connect to the database. Validate that the generated client is usable in a test script.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Design and Implement User Table Schema",
        "description": "Define the user table schema in Prisma, including fields for email, password hash, roles, and timestamps.",
        "details": "Edit `prisma/schema.prisma` to define a User model with fields: id (UUID), email (unique), passwordHash, role (enum: 'user', 'admin'), createdAt, updatedAt. Add any necessary indexes and constraints. Use Prisma migrations to apply the schema.",
        "testStrategy": "Run `prisma migrate dev` to apply the migration. Inspect the database to confirm the schema matches requirements. Attempt to insert and query user records using Prisma client.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Integrate NextAuth.js with Database Adapter",
        "description": "Set up NextAuth.js (Auth.js) for email/password authentication using the Prisma adapter and Vercel Postgres.",
        "details": "Install next-auth and configure it in the Next.js app. Use the Prisma adapter for database integration. Implement credential provider for email/password login. Configure session management and secure cookie settings. Store the admin email in an environment variable.",
        "testStrategy": "Attempt login and session creation using test users in the database. Verify session persistence and correct user data retrieval. Check that only valid credentials allow login.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Secure Password Hashing and Validation",
        "description": "Ensure all passwords are securely hashed using bcrypt before storage and validated during login.",
        "details": "Install bcrypt or bcryptjs. In the user registration and authentication logic, hash passwords before saving to the database and compare hashes during login. Never store plaintext passwords.",
        "testStrategy": "Register a user and verify the password is hashed in the database. Attempt login with correct and incorrect passwords to confirm validation logic.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Develop Admin-Only Registration Endpoint and UI",
        "description": "Create an API endpoint and frontend form for user registration, accessible only to the admin (iam1492@gmail.com).",
        "details": "Implement an API route (e.g., /api/admin/register) that checks the session for the admin email before allowing access. Build a registration form in the frontend, visible only to the admin. On submission, validate input and create new users in the database.",
        "testStrategy": "Login as admin and verify access to the registration form and endpoint. Attempt registration as a non-admin and confirm access is denied. Register a new user and check database entry.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement User and Session Management Logic",
        "description": "Add logic for user session management, including login, logout, and session validation.",
        "details": "Use NextAuth.js session APIs to manage user sessions. Protect routes and API endpoints by checking session validity. Implement logout functionality and session expiration handling.",
        "testStrategy": "Login and navigate protected routes to confirm session enforcement. Logout and verify session termination. Attempt to access protected resources without a session.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Enhance Input Validation and Security",
        "description": "Strengthen input validation, prevent SQL injection, and ensure sensitive data is encrypted.",
        "details": "Use server-side validation libraries (e.g., zod, yup) for all API inputs. Rely on Prisma's parameterized queries to prevent SQL injection. Ensure all sensitive environment variables are managed securely. Enforce HTTPS in production.",
        "testStrategy": "Submit invalid and malicious inputs to all endpoints and verify proper rejection. Review logs for security errors. Confirm HTTPS enforcement in production.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Conduct Integration and End-to-End Testing",
        "description": "Test the full authentication and registration flows, including database integration and session handling.",
        "details": "Write integration tests using tools like Jest and Playwright/Cypress. Cover scenarios: login, logout, admin registration, session persistence, and error handling. Test both local and Vercel environments.",
        "testStrategy": "Run automated test suites and manual exploratory tests. Validate all user and admin flows, including edge cases and error conditions.",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Optimize for Production and Deploy to Vercel",
        "description": "Finalize environment configuration, optimize for Vercel deployment, and implement backup strategies.",
        "details": "Set all required environment variables in Vercel. Enable Vercel Postgres backups. Review and optimize serverless/edge function usage. Deploy the app to Vercel and monitor for issues.",
        "testStrategy": "Deploy to Vercel and verify all features work as expected. Test failover and backup restoration procedures. Monitor logs and performance metrics post-deployment.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-25T00:50:58.588Z",
      "updated": "2025-10-25T00:59:10.230Z",
      "description": "Tasks for database-integration context"
    }
  },
  "telemetry-fix": {
    "tasks": [
      {
        "id": 1,
        "title": "Analyze Error Logs and Current Tracing Configuration",
        "description": "Collect and analyze detailed error logs related to GeneratorExit and context token issues. Review current OpenTelemetry tracing settings and ADK tracing-related code.",
        "details": "Gather representative error logs showing GeneratorExit and context detach failures. Review tracing configuration in both development and production environments. Examine ADK code paths where tracing and context management are handled, focusing on async generator usage and contextvar token lifecycle.",
        "testStrategy": "Verify that all known error patterns are captured. Confirm that tracing configuration matches documented settings. Ensure code review covers all relevant tracing and context management logic.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Design Safe Context Detach Mechanism for OpenTelemetry",
        "description": "Implement a robust mechanism to safely detach OpenTelemetry context tokens, especially during GeneratorExit scenarios.",
        "details": "Refactor context detach logic to avoid calling detach in GeneratorExit or when contextvars tokens were created in a different context. Use try/except blocks to catch ValueError and log or handle gracefully. Consider upstream workarounds such as ensuring all tasks complete before GC triggers GeneratorExit[1][3].",
        "testStrategy": "Unit test context detach logic with simulated GeneratorExit and cross-context token scenarios. Confirm no ValueError is raised and context is cleaned up safely.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Enhance TracingSafeAsyncGenerator Utility",
        "description": "Improve TracingSafeAsyncGenerator to standardize async generator cleanup and context management.",
        "details": "Update TracingSafeAsyncGenerator to ensure context is properly entered and exited, and that cleanup occurs safely during GeneratorExit. Add logic to prevent context detach if the token is invalid or from a different context. Document usage patterns for developers.",
        "testStrategy": "Write integration tests for async generators using TracingSafeAsyncGenerator, including forced GeneratorExit and context switching. Validate no context leaks or detach errors.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Standardize GeneratorExit Exception Handling",
        "description": "Implement a consistent approach to handling GeneratorExit exceptions across all tracing-related code.",
        "details": "Introduce utility functions or decorators to wrap generator cleanup logic, catching GeneratorExit and ensuring safe context teardown. Ensure that OpenTelemetry spans are not incorrectly marked as errors due to GeneratorExit unless truly exceptional[3].",
        "testStrategy": "Test generator workflows with and without tracing, forcibly triggering GeneratorExit. Confirm that exceptions are handled and spans are not erroneously marked as errors.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Optimize Tracing Configuration for Development and Production",
        "description": "Separate and optimize tracing settings for development and production environments, enabling selective tracing as needed.",
        "details": "Refactor configuration files or environment variable usage to allow different tracing levels per environment. Implement selective tracing logic to minimize performance impact and avoid monitoring loss when tracing is partially disabled.",
        "testStrategy": "Deploy in both environments and verify tracing behavior matches configuration. Benchmark performance impact of tracing settings.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate Performance Monitoring for Tracing Operations",
        "description": "Add performance monitoring to measure the impact of tracing and context management changes.",
        "details": "Instrument key tracing and context management code paths with metrics collection (e.g., latency, error rates, resource usage). Use OpenTelemetry metrics or compatible monitoring tools. Set up alerts for abnormal performance degradation.",
        "testStrategy": "Run load tests and monitor metrics before and after changes. Validate that performance impact is minimal and within acceptable thresholds.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Conduct Integration and Regression Testing",
        "description": "Perform comprehensive integration and regression tests to ensure all fixes work together and do not introduce new issues.",
        "details": "Develop test scenarios that reproduce known errors, including GeneratorExit and context token mismatches. Test tracing in both development and production configurations. Validate that analysis jobs complete without premature termination.",
        "testStrategy": "Automate test suite covering all error scenarios and normal workflows. Confirm all success criteria are met and no regressions occur.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Prepare for Production Deployment and Final Verification",
        "description": "Finalize code, configuration, and documentation for production deployment. Perform last-stage verification and monitoring.",
        "details": "Review all changes for completeness and adherence to requirements. Update deployment scripts and documentation. Monitor production environment post-deployment for any residual errors or performance issues.",
        "testStrategy": "Deploy to staging, run final acceptance tests, and monitor production logs and metrics for at least one full analysis cycle.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-25T14:52:34.019Z",
      "updated": "2025-10-25T14:54:10.654Z",
      "description": "Tasks for telemetry-fix context"
    }
  },
  "stock-symbol-removal": {
    "tasks": [
      {
        "id": 1,
        "title": "Analyze stock_symbol usage across codebase",
        "description": "Identify all code locations and dependencies involving stock_symbol to ensure comprehensive removal.",
        "details": "Use static code analysis tools (e.g., grep, IDE search, or specialized tools like ESLint, TypeScript strict mode) to scan the entire codebase for references to stock_symbol. Document each occurrence, including imports, variable declarations, function parameters, and usage in logic. Create a detailed inventory of affected files and modules. Consider both direct references and indirect usage (e.g., dynamic property access, string concatenation).",
        "testStrategy": "Manual review of the inventory to confirm no stock_symbol references are missed. Cross-check with a second developer for completeness.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create backup of stock_symbol related code",
        "description": "Safely archive all code and configuration files that reference stock_symbol before removal.",
        "details": "Create a dedicated backup directory (e.g., /backups/stock_symbol_removal/). Copy all files and configurations identified in Task 1 into this directory, preserving original paths for traceability. Ensure the backup is version-controlled or otherwise protected from accidental deletion. Document the backup process and location for team reference.",
        "testStrategy": "Verify that all files listed in the inventory from Task 1 exist in the backup directory. Check file integrity (e.g., diff against originals).",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Remove stock_symbol from request processing",
        "description": "Eliminate stock_symbol from all request handling logic to prevent errors and clean up the API surface.",
        "details": "Modify request validation, parsing, and processing logic to no longer expect, extract, or validate stock_symbol. Update API documentation and client-facing contracts if necessary. Ensure backward compatibility is not broken for other fields. Remove any stock_symbol-related error handling or logging.",
        "testStrategy": "Write and run unit and integration tests that simulate requests with and without stock_symbol. Verify that requests succeed without stock_symbol and that no legacy error paths are triggered. Check logs for unexpected stock_symbol-related messages.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Remove stock_symbol from agent payload formatting",
        "description": "Ensure agent result payloads no longer include or depend on stock_symbol.",
        "details": "Inspect and modify all code responsible for formatting agent results. Remove stock_symbol from payload templates, serialization logic, and any conditional logic based on its presence. Ensure that payload structure remains valid and that no fields are left undefined or null due to removal.",
        "testStrategy": "Validate payloads in test environments using mock agent results. Confirm that payloads are well-formed and that no stock_symbol field appears. Use automated assertions in test suites to enforce this.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Remove stock_symbol from session context",
        "description": "Eliminate stock_symbol from session management and context propagation.",
        "details": "Review session initialization, storage, and retrieval logic. Remove stock_symbol from session objects, context passing between components, and any session-related middleware. Ensure that session APIs and storage schemas are updated to reflect the removal.",
        "testStrategy": "Test session lifecycle operations (create, read, update, destroy) to ensure no stock_symbol is stored or retrieved. Verify that existing sessions remain functional and that new sessions do not reference stock_symbol.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Test agent result storage functionality",
        "description": "Validate that agent result storage in memory continues to operate correctly after stock_symbol removal.",
        "details": "Execute end-to-end test scenarios where agents generate results that are stored in memory. Verify that storage, retrieval, and expiration logic works as expected. Check for regressions in performance or correctness. Monitor memory usage and garbage collection to ensure no leaks are introduced.",
        "testStrategy": "Automated integration tests covering storage and retrieval of agent results. Manual spot checks in staging environments. Compare memory metrics before and after changes.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Verify production deployment without stock_symbol",
        "description": "Confirm that the system operates correctly in production after stock_symbol removal.",
        "details": "Deploy changes to a production-like environment (or production itself if safe). Monitor system behavior, error rates, and logs for issues related to stock_symbol removal. Ensure that all agent workflows, including result storage, continue to function. Prepare a rollback plan using the backup from Task 2 if critical issues arise.",
        "testStrategy": "Canary deployment or phased rollout with close monitoring. Automated health checks and alerting for stock_symbol-related errors. Post-deployment validation of agent result storage and system stability.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "in-progress",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-26T13:20:22.778Z",
      "updated": "2025-10-26T13:38:00.075Z",
      "description": "Tasks for stock-symbol-removal context"
    }
  },
  "docker-deployment": {
    "tasks": [
      {
        "id": 1,
        "title": "Provision Vultr VPS with Ubuntu 22.04",
        "description": "Set up a new Vultr VPS instance running Ubuntu 22.04 as the deployment target.",
        "details": "Use the Vultr dashboard to deploy a new server. Select Ubuntu 22.04 as the OS. Choose at least 2GB RAM (upgrade to 4GB if needed). Configure SSH access for secure remote management.",
        "testStrategy": "Verify SSH connectivity and OS version by logging in and running `lsb_release -a`.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Install Docker and Docker Compose on VPS",
        "description": "Install Docker Engine and Docker Compose on the Ubuntu VPS.",
        "details": "Follow the official Docker installation guide for Ubuntu 22.04. Install Docker Compose using the recommended method (e.g., via apt or downloading the binary). Add the current user to the docker group for non-root usage.",
        "testStrategy": "Run `docker --version` and `docker-compose --version` to confirm installations.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Dockerfile for ADK Backend (Python/FastAPI)",
        "description": "Develop a Dockerfile to containerize the ADK backend using Python 3.11 and uv package manager.",
        "details": "Start from `python:3.11-slim`. Install uv, copy source code, install dependencies via uv, expose port 8000, and set CMD to run the FastAPI app with uvicorn. Use multi-stage build to minimize image size.",
        "testStrategy": "Build the image locally and run the container. Test API endpoint with curl.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create Dockerfile for Next.js Frontend",
        "description": "Develop a Dockerfile to containerize the Next.js frontend using Node.js 20.",
        "details": "Start from `node:20-alpine`. Copy source, install dependencies, build the app, and serve static files. Use multi-stage build to reduce final image size. Expose port 3000.",
        "testStrategy": "Build and run the container locally. Access the frontend at localhost:3000.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Dockerfile for Nginx Reverse Proxy",
        "description": "Develop a Dockerfile for Nginx with a custom configuration to route traffic to frontend and backend.",
        "details": "Use the official nginx image. Copy a custom nginx.conf that proxies /api to backend:8000 and serves static files from frontend:3000. Prepare SSL config but comment out SSL directives.",
        "testStrategy": "Run the container and test routing with curl and browser.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Configure PostgreSQL Docker Container",
        "description": "Set up a PostgreSQL container with persistent storage and basic configuration.",
        "details": "Use the official postgres image. Set environment variables for user, password, and database. Mount a Docker volume for data persistence. Expose port 5432 internally.",
        "testStrategy": "Connect to the database from backend container and run basic CRUD operations.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Write docker-compose.yml for Multi-Container Orchestration",
        "description": "Define all services, networks, and volumes in a single docker-compose.yml file.",
        "details": "Specify services for backend, frontend, nginx, and postgres. Configure environment variables, build contexts, port mappings, and volumes. Set up a custom bridge network for secure inter-container communication.",
        "testStrategy": "Run `docker-compose up` and verify all containers start and communicate as expected.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Environment Variable and Secret Management",
        "description": "Set up environment variable files and secret management for sensitive data.",
        "details": "Use .env files for non-sensitive configuration. For secrets (e.g., DB passwords), use Docker secrets or environment variables with restricted permissions. Ensure .env files are excluded from version control.",
        "testStrategy": "Check that containers receive correct environment variables and secrets are not exposed in logs or images.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Configure Container Networking and Port Mapping",
        "description": "Set up Docker Compose networks and map ports according to the architecture.",
        "details": "Define a user-defined bridge network in docker-compose.yml. Map Nginx to host port 80, frontend to 3000 (internal), backend to 8000 (internal), and postgres to 5432 (internal). Ensure only Nginx is exposed to the host.",
        "testStrategy": "Verify network isolation using `docker network inspect` and test access from host and between containers.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Health Checks and Auto-Restart Policies",
        "description": "Add healthcheck directives and restart policies for all containers in docker-compose.yml.",
        "details": "Define healthcheck commands for backend, frontend, and postgres. Set restart: always for all services to ensure reliability.",
        "testStrategy": "Simulate failures and verify containers auto-restart and health status is reported.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Develop Automated Deployment Script",
        "description": "Create a shell script to automate deployment, updates, and rollback on the VPS.",
        "details": "Script should pull latest images, run docker-compose up with appropriate flags, and support rollback to previous version using tagged images or compose files.",
        "testStrategy": "Run the script on the VPS and verify successful deployment and rollback.",
        "priority": "medium",
        "dependencies": [
          2,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Set Up Logging and Monitoring for Containers",
        "description": "Configure centralized logging and basic monitoring for all containers.",
        "details": "Use Docker logging drivers (e.g., json-file or syslog). Optionally, deploy a lightweight monitoring tool (e.g., Portainer or cAdvisor) for container health and resource usage.",
        "testStrategy": "Check logs for all services and verify monitoring dashboard displays correct metrics.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Optimize Docker Images and Build Process",
        "description": "Apply multi-stage builds and remove unnecessary files to minimize image sizes.",
        "details": "Refactor Dockerfiles to use multi-stage builds. Add .dockerignore files to exclude unnecessary files. Use smaller base images where possible.",
        "testStrategy": "Compare image sizes before and after optimization. Ensure functionality is unchanged.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Database Backup and Restore Procedures",
        "description": "Set up automated backup and manual restore scripts for PostgreSQL data.",
        "details": "Use pg_dump for scheduled backups to a mounted volume or remote storage. Provide a script for restoring from backup. Document backup frequency and retention.",
        "testStrategy": "Perform a backup and restore cycle and verify data integrity.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Harden Security and Network Isolation",
        "description": "Apply basic security best practices excluding HTTPS (per requirements).",
        "details": "Restrict container privileges, use user-defined networks, limit exposed ports to only Nginx, and set file permissions. Document security settings. Prepare commented SSL config in nginx.conf for future use.",
        "testStrategy": "Run security scans (e.g., Docker Bench for Security) and verify only required ports are accessible from the host.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-28T10:50:26.845Z",
      "updated": "2025-10-28T10:55:53.774Z",
      "description": "Tasks for docker-deployment context"
    }
  },
  "agent-engine-removal": {
    "tasks": [
      {
        "id": 1,
        "title": "Inventory Agent Engine Integration in nextjs/ Folder",
        "description": "Analyze the frontend codebase to identify all files within the nextjs/ folder that reference or use agent engine functionality, producing a comprehensive inventory for removal or refactoring.",
        "details": "1. Review the entire nextjs/ directory, including all subfolders and files, focusing on code that imports, references, or interacts with agent engine modules, APIs, or related utilities.\n2. Use code search tools (e.g., grep, ripgrep, or IDE search) to locate keywords such as 'agent', 'AgentEngine', 'agent_engine', and any known integration points (e.g., API routes, service calls, or context providers).\n3. Document each file and code location where agent engine functionality is present, including:\n   - File path and line numbers\n   - Type of usage (import, function call, component usage, etc.)\n   - Brief description of the integration's purpose in that context\n4. Cross-reference findings with architectural documentation and recent commits to ensure completeness.\n5. Organize the inventory in a structured format (e.g., markdown table or spreadsheet) for easy review by engineering and product stakeholders.\n6. Highlight any code that is tightly coupled to agent engine logic and may require significant refactoring.\n7. Exclude files outside the nextjs/ folder from this analysis.",
        "testStrategy": "1. Validate that all files in nextjs/ referencing agent engine functionality are included in the inventory by running comprehensive codebase searches for relevant keywords and imports.\n2. Peer review the inventory with at least one other engineer to confirm completeness and accuracy.\n3. Spot-check a sample of files from the inventory to ensure the documented usage matches the actual code.\n4. Confirm that no agent engine references remain undiscovered by running static analysis or linting tools configured to flag such dependencies.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-01T03:55:15.383Z",
      "updated": "2025-11-01T03:58:34.189Z",
      "description": "Remove agent engine dependency and refactor to use local backend only"
    }
  },
  "model-selector-removal": {
    "tasks": [
      {
        "id": 1,
        "title": "Audit and Identify ModelSelector Usage in Frontend",
        "description": "Locate all instances of the ModelSelector component, model selection state, and related props/handlers in the nextjs frontend codebase.",
        "details": "Search the nextjs/ directory for all imports, references, and usages of ModelSelector. Identify all state management, props, and handlers related to model selection. Document all affected files and code sections for removal in subsequent tasks.",
        "testStrategy": "Verify that all ModelSelector references are identified by running a global search for 'ModelSelector', 'model', and related keywords. Confirm with code owners if any ambiguous usages are found.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Remove ModelSelector Component and Related UI Elements",
        "description": "Delete the ModelSelector component and all UI elements, state, and handlers related to model selection from the frontend.",
        "details": "Remove the ModelSelector component file(s), delete all imports and usages in chat interfaces, and eliminate model selection state and handlers. Clean up any conditional rendering or UI logic tied to model selection.",
        "testStrategy": "Run the application and confirm that no model selection UI is present. Check for missing import errors and ensure the chat interface renders correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Clean Up Model-Related Props and Dependencies in Frontend",
        "description": "Remove all model-related props, context, and dependencies from frontend components and state management.",
        "details": "Update all components that previously received model-related props or context to remove these parameters. Refactor state management to eliminate model selection logic. Remove any model-related code from Redux, Zustand, or other state libraries if used.",
        "testStrategy": "Run type checks and linter to ensure no missing props or unused variables remain. Confirm that all frontend components function as expected.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Remove Model Parameter from Frontend-Backend Communication",
        "description": "Eliminate the model parameter from all API requests, SSE, and WebSocket messages sent from the frontend.",
        "details": "Update API call functions to exclude the model parameter. Refactor SSE/WebSocket message payloads to remove model fields. Ensure all request/response interfaces are updated accordingly.",
        "testStrategy": "Monitor network requests in browser dev tools to confirm no model parameter is sent. Validate that all communication with the backend still succeeds.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Audit and Identify Model Handling in Backend",
        "description": "Locate all backend code in the app/ directory that handles model parameters, validation, or processing.",
        "details": "Search for model-related parameters in API endpoint definitions, request parsing, and business logic. Document all affected files and code sections for removal or refactoring.",
        "testStrategy": "Verify all model-related backend code is identified by searching for 'model', 'modelName', and similar terms. Cross-check with frontend changes to ensure alignment.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Remove Model Parameter Handling and Validation in Backend",
        "description": "Delete all backend logic related to model parameter handling, validation, and processing.",
        "details": "Remove model parameter parsing from API endpoints, eliminate validation logic, and refactor business logic to use the hardcoded 'gemini-2.5-flash' model. Update any affected tests or documentation.",
        "testStrategy": "Run backend unit and integration tests to ensure endpoints function correctly without model parameters. Confirm that the hardcoded model is always used.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Remove Model Parameter from Backend Communication Interfaces",
        "description": "Update backend SSE/WebSocket and API response interfaces to remove model-related fields.",
        "details": "Refactor response payloads to exclude model fields. Update any interface/type definitions and ensure backward compatibility for all other fields.",
        "testStrategy": "Test all backend endpoints and real-time interfaces to confirm no model fields are present in responses. Validate with frontend integration.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Final Codebase Cleanup and Regression Testing",
        "description": "Remove any dead code, unused imports, and ensure no references to model selection remain. Perform full regression testing.",
        "details": "Run static analysis tools to detect unused code. Manually review recent commits for any lingering model-related logic. Execute full application regression tests to ensure all features work as expected and no console errors or warnings are present.",
        "testStrategy": "Run automated and manual regression tests. Check application logs and browser console for errors or warnings. Confirm all success criteria from the PRD are met.",
        "priority": "high",
        "dependencies": [
          4,
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-03T21:39:06.120Z",
      "updated": "2025-11-03T21:39:45.699Z",
      "description": "Tasks for model-selector-removal context"
    }
  },
  "firestore-integration": {
    "tasks": [
      {
        "id": 1,
        "title": "Add Firestore Python SDK and Environment Configuration",
        "description": "Install firebase-admin, update dependencies, and configure environment variables for Firestore integration.",
        "details": "Add 'firebase-admin>=6.0.0' to pyproject.toml. Update .env and .env.production with FIREBASE_PROJECT_ID and FIREBASE_CREDENTIALS_PATH. Ensure service account JSON is securely stored and not committed to git. Document setup steps for credentials and environment variables in guide/FIRESTORE_SETUP.md.",
        "testStrategy": "Verify that the dependency is installed and environment variables are loaded correctly. Attempt to load credentials from the specified path and check for errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Firestore Client Initialization",
        "description": "Initialize Firestore client at application startup using Firebase Admin SDK and environment variables.",
        "details": "In app/sub_agents/utils/firestore_config.py, use firebase_admin and credentials.Certificate to initialize the app with the service account JSON. Use firestore.client() to obtain the Firestore client. Implement singleton pattern to ensure only one client is created. Example:\n\n```python\nimport firebase_admin\nfrom firebase_admin import credentials, firestore\n\nclass FirestoreConfig:\n    _instance = None\n    def __new__(cls):\n        if cls._instance is None:\n            cred = credentials.Certificate(os.getenv('FIREBASE_CREDENTIALS_PATH'))\n            firebase_admin.initialize_app(cred)\n            cls._instance = firestore.client()\n        return cls._instance\n```\n",
        "testStrategy": "Unit test: Mock environment variables and credentials, verify Firestore client is initialized once. Integration test: Use real credentials and check connection to Firestore.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Centralized Model Configuration Service",
        "description": "Develop a service to load and cache agent-to-model mappings from Firestore at startup.",
        "details": "In app/sub_agents/utils/firestore_config.py, implement a class that loads all documents from the 'stock_agents' collection, mapping agent_name to llm_model. Cache the mapping in memory (e.g., a dictionary). Provide a method get_model(agent_name: str) -> str. Ensure loading is performed once at startup and supports parallel loading for performance. Add timeout handling (max 5 seconds).",
        "testStrategy": "Unit test: Mock Firestore client, verify all agent configs are loaded and cached. Test timeout and error handling. Integration test: Load real data from Firestore and check mapping correctness.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Modify llm_model.py for Dynamic Model Lookup",
        "description": "Refactor llm_model.py to use the configuration service for agent-specific model selection with fallback logic.",
        "details": "Change lite_llm_model() to accept agent_name as a parameter. Call the configuration service's get_model(agent_name) method. If the agent is not found or Firestore is unavailable, return the default model ('gemini-2.5-flash'). Log warnings for missing or invalid configurations. Ensure backward compatibility for callers not passing agent_name.",
        "testStrategy": "Unit test: Pass various agent names, including missing and invalid ones, and verify correct model or fallback is returned. Check logging for missing configs.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Update Agent Creation Functions for Model Parameterization",
        "description": "Update all agent creation functions to pass agent_name to lite_llm_model and use the returned model.",
        "details": "Refactor agent creation code throughout the backend to ensure each agent passes its unique name to lite_llm_model when setting the model parameter. Ensure all 11 agents are covered. Maintain compatibility with existing agent hierarchy and logic.",
        "testStrategy": "Unit test: Mock lite_llm_model and verify correct agent_name is passed for each agent. Integration test: Start backend and confirm all agents use the correct model from Firestore.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Robust Error Handling and Logging",
        "description": "Ensure all Firestore and configuration errors are handled gracefully with appropriate logging and fallback.",
        "details": "In the configuration service and llm_model.py, catch exceptions related to Firestore connectivity, missing configs, and invalid model names. Always fallback to 'gemini-2.5-flash' if any error occurs. Log all warnings and errors with sufficient detail for troubleshooting. Never allow startup to fail due to Firestore issues.",
        "testStrategy": "Unit test: Simulate Firestore unavailability, missing agent configs, and invalid data. Verify fallback and logging. Integration test: Remove Firestore access and confirm system starts and logs warnings.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Write Unit and Integration Tests for Configuration System",
        "description": "Develop comprehensive tests for Firestore loader, fallback logic, and agent model selection.",
        "details": "Create unit tests for the configuration loader using mock Firestore data. Test fallback behavior when Firestore is unavailable or agent config is missing. Write integration tests to connect to real Firestore and verify all 11 agents load correct models. Test model changes via Firebase Console and backend restart.",
        "testStrategy": "Run all tests with and without Firestore access. Change model configs in Firebase Console and verify effects after restart. Use coverage tools to ensure all code paths are tested.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Document Setup, Configuration, and Usage",
        "description": "Write and update documentation for Firestore setup, environment configuration, and model management.",
        "details": "Update guide/FIRESTORE_SETUP.md with steps for creating a Firebase service account, storing credentials, and configuring environment variables. Update guide/MODEL_CONFIGURATION.md with instructions for changing agent models via Firebase Console, supported model names, and troubleshooting. Document fallback behavior and logging.",
        "testStrategy": "Review documentation for completeness and clarity. Follow setup steps on a clean environment to ensure accuracy.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-04T10:03:23.559Z",
      "updated": "2025-11-04T10:20:48.069Z",
      "description": "Tasks for firestore-integration context"
    }
  }
}